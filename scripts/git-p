#!/bin/bash

#TODO change this to use getopt instead
if [ -n "$1" ] ;then
    USE_MASTER=1
else
    USE_MASTER=0
fi

#########################
#Update root repo
#########################
git pull "$@"

#########################
#Update all submodules
#########################
#first sync up the '.gitmodules' files with the submodules
git submodule sync

#Record current directory for later
ORIG_PWD=$PWD

#get gitmodule files
fil_array=() #get an array of gitmodule files
while IFS=  read -r -d $'\0';
  do fil_array+=("$REPLY");
done < <(find . -name "\.gitmodules" -print0)

fil_array_len=${!fil_array[@]}



#Return the branch of the current directory. If any argument is passed in returns the commit id if in detached head state
getBranch() {
    CUR_BRANCH="$(git branch | head -n 1 |cut -c 3-)"
    if [ -n "$1" ] && [ "${CUR_BRANCH/detached from}" != "$CUR_BRANCH" ]; then #handle special detached head case
        CUR_BRANCH="$(git branch | head -n 1 |cut -c 18-|cut -f1 -d')')"
        DETACHED_HEAD=1
    fi
}

#for each gitmodule file...
for i in "${fil_array[@]}"
do
    :
    #cd to gitmodule file directory
    cd $(dirname "$i")
    #read each submodule location from the .gitmodules file
    sub_array=(); while IFS=  read -r -d $'\n'; do sub_array+=("$REPLY"); done < <(cat ./.gitmodules | grep "path =" | rev|cut -d' ' -f1|rev)

    #for each defined submodule...
    for j in "${sub_array[@]}"
    do
        :
        #cd to that submodule and update it

        cd "$j"; git fetch
        #attempt to merge in which ever branch it is currently on
        CUR_BRANCH= #the current branch
        DETACHED_HEAD=0 #1 if in detached head state, 0 otherwise
        getBranch 1

        if [ "$DETACHED_HEAD" -eq 1 ]; then #handle special detached head case

            if [ "$USE_MASTER" -eq 1 ]; then
                CHECKOUT=master
            else
                echo -e "Submodule '$(dirname $i)/$j' curently in detached head state. Checkout branch or skip?\n\tskip [default]\n$(git branch -a)"
                read CHECKOUT
            fi

            if [ "$CHECKOUT" != '' ] ; then
                git checkout "$CHECKOUT"
                CUR_BRANCH=$(git branch | head -n 1 |cut -c 3-)
            fi
        fi
        if [ -n "$CUR_BRANCH" ] ; then
            git merge --no-commit origin/"$CUR_BRANCH" #TODO don't make the assumption remote branch is named origin

            #check the return code for a git conflict
            if [ "$?" -eq 0 ]; then
                git merge
            else
                echo git merge conflict updating $(basename "$PWD")
            fi


        fi
        #Return to root of submodule containing repo
        cd "$ORIG_PWD"; cd $(dirname "$i")

    done

    #return to original location
    cd "$ORIG_PWD"

done

#read its path
#cd to the submodule
#update
#don't use this because it puts the submodules in detach head state
#git submodule update --init --recursive "$@"
